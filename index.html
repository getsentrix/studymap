<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Map Quiz Studio – REAL AI Vision Enhanced</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121835; --muted:#1a2250; --text:#e7ecff; --accent:#7aa2ff; --good:#34d399; --bad:#ef4444; --warn:#f59e0b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%; overflow-x:hidden;}
    body{margin:0; background:radial-gradient(1200px 800px at 20% -10%,#1a224a 0%, rgba(26,34,74,0) 60%), var(--bg); color:var(--text); font:500 15px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .app{display:grid; grid-template-columns: 340px 1fr; gap:18px; height:100%; padding:18px; min-height:100vh;}
    header{grid-column: 1 / -1; display:flex; align-items:center; justify-content:space-between; padding:10px 16px; background:linear-gradient(180deg, rgba(122,162,255,.25), transparent); border:1px solid rgba(122,162,255,.25); border-radius: var(--radius); box-shadow: var(--shadow)}
    h1{font-size:18px; letter-spacing:.2px; margin:0; display:flex; align-items:center; gap:10px}
    h1 .dot{width:10px; height:10px; border-radius:50%; background:var(--accent); box-shadow:0 0 12px var(--accent)}

    .panel{background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.2)); border:1px solid rgba(122,162,255,.15); border-radius:var(--radius); box-shadow: var(--shadow)}
    .left{display:flex; flex-direction:column; gap:14px; padding:14px; max-height:calc(100vh - 120px); overflow-y:auto;}

    .group{background:rgba(255,255,255,.02); border:1px solid rgba(255,255,255,.06); border-radius:14px; padding:12px}
    .group h3{margin:0 0 8px; font-size:13px; text-transform:uppercase; letter-spacing:.12em; color:#bcd2ff}

    .controls{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
    .controls .row{grid-column:1/-1; display:flex; gap:8px}

    .btn{appearance:none; border:none; background:linear-gradient(180deg, #223066, #1a2550); color:var(--text); padding:10px 12px; border-radius:12px; cursor:pointer; transition:.2s transform, .2s box-shadow, .2s background; box-shadow: 0 6px 14px rgba(0,0,0,.25); font-weight:600; user-select:none;}
    .btn:hover{transform: translateY(-1px); box-shadow: 0 8px 18px rgba(0,0,0,.32)}
    .btn:active{transform: translateY(0)}
    .btn:disabled{opacity:0.5; cursor:not-allowed; transform:none;}
    .btn.secondary{background:linear-gradient(180deg, #1b244a, #141a39)}
    .btn.good{background:linear-gradient(180deg, #2aa56a, #1f7e52)}
    .btn.bad{background:linear-gradient(180deg, #b03838, #8a2c2c)}
    .btn.warn{background:linear-gradient(180deg, #b47a23, #8a5e1b)}
    .btn.ghost{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.12)}
    .btn.ai{background:linear-gradient(135deg, #6366f1, #8b5cf6); position:relative; overflow:hidden;}
    .btn.ai::before{content:'🧠'; position:absolute; left:8px; top:50%; transform:translateY(-50%); font-size:14px;}
    .btn.ai{padding-left:28px;}

    input[type="file"]{display:none}
    label.file{display:inline-flex; align-items:center; gap:8px}

    .chips{display:flex; flex-wrap:wrap; gap:6px}
    .chip{background:rgba(122,162,255,.12); border:1px solid rgba(122,162,255,.25); color:#dbe6ff; padding:6px 10px; border-radius:999px; font-size:12px; cursor:pointer; transition:.2s; user-select:none;}
    .chip:hover{background:rgba(122,162,255,.2)}

    .terms{max-height: 240px; overflow:auto; border-radius: 10px; border:1px solid rgba(255,255,255,.06)}
    .term{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 10px; background:rgba(255,255,255,.02); border-bottom:1px solid rgba(255,255,255,.06)}
    .term:last-child{border-bottom:none}
    .term span{white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .term .mini{display:flex; gap:6px}

    .right{position:relative; padding:12px; min-height:500px;}
    .stage{position:relative; height: calc(100% - 0px); border-radius: var(--radius); overflow:hidden; background:#0a0f22; border:1px solid rgba(122,162,255,.15); min-height:400px;}
    canvas{width:100%; height:100%; display:block; background:#090e20; touch-action:none;}

    .overlay{position:absolute; inset:0; pointer-events:none; display:flex; align-items:flex-start; justify-content:space-between; padding:12px}
    .badge{pointer-events:auto; background:rgba(13,20,44,.8); backdrop-filter: blur(3px); border:1px solid rgba(122,162,255,.25); border-radius:12px; padding:10px 12px; display:flex; align-items:center; gap:10px; box-shadow: var(--shadow)}
    .badge .title{font-weight:700}

    .bottombar{position:absolute; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:space-between; gap:10px; padding:12px}

    .mode-toggle{display:flex; gap:8px}

    .toast{position:absolute; left:50%; transform:translate(-50%, 20px); bottom:24px; background:rgba(20,28,60,.95); border:1px solid rgba(255,255,255,.12); padding:12px 16px; border-radius:12px; opacity:0; pointer-events:none; z-index:1000;}
    .toast.show{animation:toast 1.6s ease forwards}
    @keyframes toast{0%{opacity:0; transform:translate(-50%, 20px)} 10%,85%{opacity:1; transform:translate(-50%, 0)} 100%{opacity:0; transform:translate(-50%, 20px)}}

    .pin{position:absolute; width:18px; height:18px; border-radius:50%; background:var(--accent); box-shadow:0 0 0 0 rgba(122,162,255,.6); animation:pulse 1.6s infinite; transform:translate(-50%, -100%); border:2px solid white}
    .pin.quiz{background:#bbb; animation:none}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(122,162,255,.6)} 100%{box-shadow:0 0 0 18px rgba(122,162,255,0)}}

    .flashcard{position:absolute; right:12px; top:12px; width:min(380px, 36%); background:rgba(15,22,50,.92); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:14px; display:none}
    .flashcard.show{display:block; animation: pop .22s ease}
    @keyframes pop{from{transform:scale(.98); opacity:0} to{transform:scale(1); opacity:1}}
    .flashcard h4{margin:0 0 6px}
    .progress{height:8px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden}
    .progress > div{height:100%; width:0; background:linear-gradient(90deg, var(--accent), #9ad0ff); transition:width 0.3s ease;}

    .shake{animation: shake .25s linear 2}
    @keyframes shake{0%{transform:translateX(0)} 25%{transform:translateX(-6px)} 50%{transform:translateX(6px)} 75%{transform:translateX(-4px)} 100%{transform:translateX(0)}}

    .pill{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); font-size:12px}
    .small{font-size:12px; opacity:.9}
    .hint{color:#bcd2ff}

    .loading{opacity:0.5; pointer-events:none;}
    .error{color:var(--bad); font-weight:600;}

    /* AI Modal Styles */
    .modal{position:fixed; inset:0; background:rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index:10000; padding:20px;}
    .modal.show{display:flex;}
    .modal-content{background:var(--panel); border:1px solid rgba(122,162,255,.25); border-radius:var(--radius); padding:24px; max-width:700px; width:100%; max-height:85vh; overflow-y:auto; box-shadow: var(--shadow);}
    .modal-header{display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;}
    .modal-title{font-size:20px; font-weight:700; color:var(--accent);}
    .close-btn{background:none; border:none; color:var(--text); font-size:24px; cursor:pointer; padding:4px; border-radius:4px;}
    .close-btn:hover{background:rgba(255,255,255,.1);}

    .step{margin-bottom:20px; padding:16px; background:rgba(255,255,255,.02); border-radius:12px; border:1px solid rgba(255,255,255,.06);}
    .step-title{font-weight:600; margin-bottom:8px; color:var(--good);}
    .step-desc{font-size:13px; color:#bcd2ff; margin-bottom:12px;}

    .map-preview{width:100%; max-height:200px; object-fit:contain; border-radius:8px; border:1px solid rgba(255,255,255,.1);}
    .map-placeholder{width:100%; height:200px; background:rgba(255,255,255,.02); border:1px dashed rgba(255,255,255,.2); border-radius:8px; display:flex; align-items:center; justify-content:center; color:#888; font-style:italic;}

    .api-input{background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); color:var(--text); padding:8px 12px; border-radius:8px; font-family:monospace; font-size:12px; width:100%;}
    .api-input:focus{outline:none; border-color:var(--accent);}
    .api-status{padding:8px 12px; border-radius:8px; font-size:12px; margin-top:8px;}
    .api-status.ok{background:rgba(52,211,153,.1); border:1px solid var(--good); color:var(--good);}
    .api-status.error{background:rgba(239,68,68,.1); border:1px solid var(--bad); color:var(--bad);}

    .ai-status{padding:12px; background:rgba(122,162,255,.1); border-radius:8px; margin:12px 0; text-align:center;}
    .ai-loading{display:inline-block; width:20px; height:20px; border:2px solid rgba(122,162,255,.3); border-top:2px solid var(--accent); border-radius:50%; animation:spin 1s linear infinite; margin-right:8px;}
    @keyframes spin{0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)}}

    .results-preview{max-height:300px; overflow-y:auto; background:rgba(0,0,0,.2); border-radius:8px; padding:12px; font-family:monospace; font-size:11px; border:1px solid rgba(255,255,255,.1); white-space:pre-wrap;}

    /* Responsive design */
    @media (max-width: 768px) {
      .app{grid-template-columns: 1fr; grid-template-rows: auto auto 1fr; padding:10px;}
      .left{max-height:none; order:2;}
      .right{order:3; min-height:300px;}
      header{order:1;}
      .flashcard{position:fixed; left:12px; right:12px; top:12px; width:auto;}
      .modal-content{margin:10px; padding:16px;}
    }

    .tooltip{position:absolute; transform:translate(-50%, -120%); background:#0f1736; border:1px solid rgba(255,255,255,.15); padding:6px 8px; border-radius:8px; font-size:12px; white-space:nowrap; z-index:1001;}
  </style>
</head>
<body>
  <div class="app">
    <header class="panel">
      <h1><span class="dot"></span> Map Quiz Studio <span class="small" style="opacity:.65">– REAL AI Vision Enhanced</span></h1>
      <div style="display:flex; gap:8px; align-items:center">
        <button class="btn ai" id="aiMapperBtn" title="REAL AI Vision text detection">Real AI Vision</button>
        <button class="btn ghost" id="exportBtn" title="Export deck JSON">Export</button>
        <input id="importInput" type="file" accept="application/json" />
        <label for="importInput" class="btn ghost">Import</label>
        <button class="btn bad" id="resetBtn" title="Clear everything">Reset</button>
      </div>
    </header>

    <aside class="left panel">
      <div class="group">
        <h3>Map image</h3>
        <div class="controls">
          <input id="imgInput" type="file" accept="image/*" />
          <label for="imgInput" class="btn" title="Upload a map image">Upload image</label>
          <button class="btn secondary" id="fitBtn">Fit to screen</button>
          <button class="btn secondary" id="clearImgBtn">Remove image</button>
        </div>
        <div style="margin-top:8px" class="small hint">Upload your map image. Use REAL AI Vision to automatically detect all text labels with precise coordinates!</div>
        <div id="imageError" class="error" style="display:none; margin-top:8px;"></div>
      </div>

      <div class="group">
        <h3>Modes</h3>
        <div class="mode-toggle">
          <button class="btn good" data-mode="author">Author</button>
          <button class="btn" data-mode="quiz">Quiz</button>
          <button class="btn" data-mode="flash">Flashcards</button>
        </div>
        <div style="margin-top:10px; display:flex; align-items:center; gap:10px">
          <label class="pill">Tolerance: <span id="tolVal">24</span> px</label>
          <input id="tol" type="range" min="10" max="60" value="24" />
        </div>
        <div style="margin-top:8px" class="small hint">Tolerance controls how close your click must be to count as correct.</div>
      </div>

      <div class="group">
        <h3>Terms</h3>
        <div class="row">
          <input id="termInput" placeholder="Add a term (e.g., Red Sea)" class="btn ghost" style="width:100%; text-align:left; font-weight:500" maxlength="50" />
          <button class="btn" id="addTerm">Add</button>
        </div>
        <div class="chips" style="margin-top:8px">
          <span class="chip" data-pack="countries">Load Middle East – Countries</span>
          <span class="chip" data-pack="features">Load Middle East – Features</span>
          <span class="chip" id="clearTerms">Clear terms</span>
        </div>
        <div class="terms" id="termList" style="margin-top:10px"></div>
      </div>

      <div class="group">
        <h3>Quiz settings</h3>
        <div class="controls">
          <div class="row" style="gap:8px">
            <button class="btn good" id="startQuiz">Start / Shuffle</button>
            <button class="btn secondary" id="showPins">Toggle pins</button>
          </div>
          <div class="row" style="gap:8px">
            <button class="btn warn" id="revealBtn">Reveal answer</button>
            <button class="btn secondary" id="undoBtn">Undo last pin</button>
          </div>
        </div>
        <div class="small hint" style="margin-top:8px">Author mode: select a term, then click map to place its pin. Drag to move (desktop). Use AI Vision for automatic placement!</div>
      </div>
    </aside>

    <main class="right panel">
      <div class="stage" id="stage">
        <canvas id="canvas"></canvas>
        <div class="overlay">
          <div class="badge">
            <span class="title" id="modeLabel">Author mode</span>
            <span class="pill" id="status">No image</span>
          </div>
          <div class="badge" id="scoreBox">
            <span>Score: <b id="score">0</b>/<b id="total">0</b></span>
            <span class="pill">Streak: <b id="streak">0</b></span>
          </div>
        </div>
        <div class="flashcard" id="flash">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:8px">
            <h4 id="fcTerm">Term</h4>
            <div class="pill" id="fcProgress">0 / 0</div>
          </div>
          <div class="progress" style="margin:8px 0 10px"><div id="fcBar"></div></div>
          <div class="small hint" id="fcHint">Click the map to guess. Press Space to flip / Next.</div>
          <div style="display:flex; gap:8px; margin-top:8px">
            <button class="btn good" id="fcKnow">I knew it</button>
            <button class="btn secondary" id="fcUnsure">Unsure</button>
            <button class="btn" id="fcNext">Next ▶</button>
          </div>
        </div>
        <div class="bottombar">
          <div class="badge">
            <span>Target: <b id="targetName">—</b></span>
          </div>
          <div style="display:flex; gap:8px">
            <button class="btn" id="nextBtn">Next</button>
          </div>
        </div>
        <div class="toast" id="toast"></div>
      </div>
    </main>
  </div>

  <!-- REAL AI Vision Modal -->
  <div class="modal" id="aiModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">🧠 Real AI Vision Text Detection</div>
        <button class="close-btn" id="closeAiModal">&times;</button>
      </div>

      <div class="step">
        <div class="step-title">Step 0: API Configuration</div>
        <div class="step-desc">Enter your Google Vision API key to enable real AI text detection.</div>
        <div style="margin-bottom:12px;">
          <label class="small">Google Vision API Key:</label>
          <input type="password" id="apiKey" class="api-input" placeholder="Enter your Google Vision API key..." />
          <div id="apiStatus" class="api-status" style="display:none;"></div>
        </div>
        <div class="small hint">
          Get your free API key: 
          <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color:var(--accent)">Google Cloud Console</a>
          • Free tier: 1000 requests/month
        </div>
      </div>

      <div class="step">
        <div class="step-title">Step 1: Upload Map Image</div>
        <div class="step-desc">Upload a clear map image with readable text labels for geographical features.</div>
        <input id="aiImgInput" type="file" accept="image/*" style="display:none;" />
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <label for="aiImgInput" class="btn">Choose Map Image</label>
          <button class="btn secondary" id="useCurrentImg" disabled>Use Current Image</button>
        </div>
        <div id="mapPreviewContainer">
          <div class="map-placeholder">No image selected</div>
        </div>
      </div>

      <div class="step">
        <div class="step-title">Step 2: Detection Settings</div>
        <div class="step-desc">Configure AI text detection parameters for optimal results.</div>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin:12px 0;">
          <div>
            <label class="small">Min Confidence: <span id="confidenceVal">70%</span></label>
            <input type="range" id="minConfidence" min="0.5" max="1.0" step="0.05" value="0.7" style="width:100%;" />
          </div>
          <div>
            <label class="small">Min Text Size: <span id="textSizeVal">12px</span></label>
            <input type="range" id="minTextSize" min="8" max="50" value="12" style="width:100%;" />
          </div>
        </div>
      </div>

      <div class="step">
        <div class="step-title">Step 3: AI Processing</div>
        <div class="step-desc">Real AI will analyze your image and detect all text labels with precise pixel coordinates.</div>
        <button class="btn ai" id="startRealAiProcessing" disabled>🚀 Analyze with Google Vision AI</button>
        <div class="ai-status" id="aiStatus" style="display:none;">
          <div class="ai-loading"></div>
          <span id="aiStatusText">Processing...</span>
        </div>
      </div>

      <div class="step" id="resultsStep" style="display:none;">
        <div class="step-title">Step 4: AI Detection Results</div>
        <div class="step-desc">Review all detected text labels and their precise coordinates.</div>
        <div class="results-preview" id="resultsPreview"></div>
        <div style="display:flex; gap:8px; margin-top:12px;">
          <button class="btn good" id="importAiResults">Import All Labels</button>
          <button class="btn secondary" id="downloadAiResults">Download JSON</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== SAFE DOM HELPERS ======
    const $ = sel => {
      try {
        return document.querySelector(sel);
      } catch(e) {
        console.warn('Invalid selector:', sel);
        return null;
      }
    };

    const $$ = sel => {
      try {
        return Array.from(document.querySelectorAll(sel));
      } catch(e) {
        console.warn('Invalid selector:', sel);
        return [];
      }
    };

    // Safe classList operations
    const safeAddClass = (element, className) => {
      if(element && element.classList) {
        element.classList.add(className);
      }
    };

    const safeRemoveClass = (element, className) => {
      if(element && element.classList) {
        element.classList.remove(className);
      }
    };

    const safeToggleClass = (element, className, force) => {
      if(element && element.classList) {
        return element.classList.toggle(className, force);
      }
      return false;
    };

    const safeHasClass = (element, className) => {
      if(element && element.classList) {
        return element.classList.contains(className);
      }
      return false;
    };

    // ====== State ======
    const state = {
      mode: 'author', // 'author' | 'quiz' | 'flash'
      image: null,
      imageNatural: {w:0,h:0},
      pins: {},           // term -> {x:0..1,y:0..1}
      terms: [],
      selectedTerm: null,
      showPins: true,
      tol: 24,
      quizOrder: [],
      quizIndex: 0,
      score: 0,
      streak: 0,
      history: [], // for undo
      isLoading: false,
      toastQueue: [],
      apiKey: '',
      aiResults: null,
    };

    // ====== Canvas setup ======
    const canvas = $('#canvas');
    const ctx = canvas ? canvas.getContext('2d') : null;
    let resizeTimeout;

    function resizeCanvas(){
      if(!canvas || !ctx) return;

      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        try {
          const stage = $('#stage');
          if(!stage) return;

          const rect = stage.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          canvas.width = rect.width * dpr; 
          canvas.height = rect.height * dpr;
          canvas.style.width = rect.width + 'px';
          canvas.style.height = rect.height + 'px';
          ctx.scale(dpr, dpr);
          draw();
        } catch(e) {
          console.error('Canvas resize error:', e);
        }
      }, 100);
    }

    window.addEventListener('resize', resizeCanvas);

    // ====== Image handling ======
    const imgEl = new Image();
    imgEl.onload = () => {
      try {
        state.imageNatural = {w: imgEl.naturalWidth || 1, h: imgEl.naturalHeight || 1};
        state.isLoading = false;
        const imageError = $('#imageError');
        if(imageError) imageError.style.display = 'none';
        toast('Image loaded successfully');
        draw();
        updateStatus();
        persist();
        updateAiButtons();
      } catch(e) {
        handleImageError('Failed to process image');
      }
    };

    imgEl.onerror = () => handleImageError('Failed to load image');

    function handleImageError(message) {
      state.isLoading = false;
      state.image = null;
      const imageError = $('#imageError');
      if(imageError) {
        imageError.textContent = message;
        imageError.style.display = 'block';
      }
      updateStatus();
      toast('Error: ' + message);
      updateAiButtons();
    }

    const imgInput = $('#imgInput');
    if(imgInput) {
      imgInput.addEventListener('change', e=>{
        const file = e.target.files[0]; 
        if(!file) return;

        // Validate file
        if (!file.type.startsWith('image/')) {
          handleImageError('Please select a valid image file');
          return;
        }

        if (file.size > 10 * 1024 * 1024) { // 10MB limit
          handleImageError('Image too large. Please use an image under 10MB');
          return;
        }

        state.isLoading = true;
        updateStatus();

        const fr = new FileReader();
        fr.onload = () => { 
          try {
            imgEl.src = fr.result; 
            state.image = fr.result; 
          } catch(e) {
            handleImageError('Failed to read image file');
          }
        };
        fr.onerror = () => handleImageError('Failed to read file');
        fr.readAsDataURL(file);
      });
    }

    const clearImgBtn = $('#clearImgBtn');
    if(clearImgBtn) {
      clearImgBtn.onclick = ()=>{ 
        state.image=null; 
        imgEl.src=''; 
        state.imageNatural = {w:0,h:0};
        const imageError = $('#imageError');
        if(imageError) imageError.style.display = 'none';
        draw(); 
        updateStatus(); 
        persist();
        updateAiButtons();
      };
    }

    const fitBtn = $('#fitBtn');
    if(fitBtn) {
      fitBtn.onclick = ()=>{ 
        if(!state.image) {
          toast('No image to fit');
          return;
        }
        draw(); 
        toast('Fitted to screen'); 
      };
    }

    function updateAiButtons() {
      const useCurrentImg = $('#useCurrentImg');
      if(useCurrentImg) {
        useCurrentImg.disabled = !state.image;
      }

      const startBtn = $('#startRealAiProcessing');
      if(startBtn) {
        startBtn.disabled = !state.apiKey || !state.image;
      }
    }

    // ====== API Key Management ======
    const apiKeyInput = $('#apiKey');
    if(apiKeyInput) {
      // Load saved API key
      const savedKey = localStorage.getItem('google_vision_api_key');
      if(savedKey) {
        state.apiKey = savedKey;
        apiKeyInput.value = savedKey;
        updateApiStatus();
      }

      apiKeyInput.addEventListener('input', (e) => {
        state.apiKey = e.target.value.trim();
        localStorage.setItem('google_vision_api_key', state.apiKey);
        updateApiStatus();
        updateAiButtons();
      });
    }

    function updateApiStatus() {
      const status = $('#apiStatus');
      if(!status) return;

      if(!state.apiKey) {
        status.style.display = 'none';
        return;
      }

      status.style.display = 'block';
      if(state.apiKey.length < 20) {
        status.className = 'api-status error';
        status.textContent = '⚠️ API key seems too short';
      } else {
        status.className = 'api-status ok';
        status.textContent = '✅ API key configured';
      }
    }

    // ====== AI Auto-Mapping ======
    let aiImage = null;

    const aiMapperBtn = $('#aiMapperBtn');
    if(aiMapperBtn) {
      aiMapperBtn.onclick = () => {
        const aiModal = $('#aiModal');
        if(aiModal) {
          safeAddClass(aiModal, 'show');
          resetAiModal();
        }
      };
    }

    const closeAiModal = $('#closeAiModal');
    if(closeAiModal) {
      closeAiModal.onclick = () => {
        const aiModal = $('#aiModal');
        if(aiModal) {
          safeRemoveClass(aiModal, 'show');
        }
      };
    }

    const aiModal = $('#aiModal');
    if(aiModal) {
      aiModal.onclick = (e) => {
        if(e.target === aiModal) {
          safeRemoveClass(aiModal, 'show');
        }
      };
    }

    function resetAiModal() {
      aiImage = null;
      state.aiResults = null;
      const mapPreviewContainer = $('#mapPreviewContainer');
      if(mapPreviewContainer) {
        mapPreviewContainer.innerHTML = '<div class="map-placeholder">No image selected</div>';
      }

      const aiStatus = $('#aiStatus');
      if(aiStatus) aiStatus.style.display = 'none';

      const resultsStep = $('#resultsStep');
      if(resultsStep) resultsStep.style.display = 'none';

      updateAiButtons();
    }

    const aiImgInput = $('#aiImgInput');
    if(aiImgInput) {
      aiImgInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if(!file) return;

        if (!file.type.startsWith('image/')) {
          toast('Please select a valid image file');
          return;
        }

        const fr = new FileReader();
        fr.onload = () => {
          aiImage = fr.result;
          const img = document.createElement('img');
          img.src = aiImage;
          img.className = 'map-preview';
          const mapPreviewContainer = $('#mapPreviewContainer');
          if(mapPreviewContainer) {
            mapPreviewContainer.innerHTML = '';
            mapPreviewContainer.appendChild(img);
          }
          updateAiButtons();
        };
        fr.readAsDataURL(file);
      });
    }

    const useCurrentImg = $('#useCurrentImg');
    if(useCurrentImg) {
      useCurrentImg.onclick = () => {
        if(!state.image) return;
        aiImage = state.image;
        const img = document.createElement('img');
        img.src = aiImage;
        img.className = 'map-preview';
        const mapPreviewContainer = $('#mapPreviewContainer');
        if(mapPreviewContainer) {
          mapPreviewContainer.innerHTML = '';
          mapPreviewContainer.appendChild(img);
        }
        updateAiButtons();
        toast('Using current map image');
      };
    }

    // Confidence and text size sliders
    const minConfidence = $('#minConfidence');
    const confidenceVal = $('#confidenceVal');
    if(minConfidence && confidenceVal) {
      minConfidence.addEventListener('input', (e) => {
        confidenceVal.textContent = Math.round(e.target.value * 100) + '%';
      });
    }

    const minTextSize = $('#minTextSize');
    const textSizeVal = $('#textSizeVal');
    if(minTextSize && textSizeVal) {
      minTextSize.addEventListener('input', (e) => {
        textSizeVal.textContent = e.target.value + 'px';
      });
    }

    // ====== REAL AI PROCESSING ======
    const startRealAiProcessing = $('#startRealAiProcessing');
    if(startRealAiProcessing) {
      startRealAiProcessing.onclick = async () => {
        if(!state.apiKey) {
          toast('Please enter your Google Vision API key');
          return;
        }

        if(!aiImage) {
          toast('Please select an image');
          return;
        }

        try {
          const aiStatus = $('#aiStatus');
          const aiStatusText = $('#aiStatusText');

          if(aiStatus) aiStatus.style.display = 'block';
          if(aiStatusText) aiStatusText.textContent = 'Preparing image for AI analysis...';

          // Convert image for API
          const imageForApi = aiImage || state.image;

          if(aiStatusText) aiStatusText.textContent = 'Sending to Google Vision API...';

          // Call REAL Google Vision API
          const detectionResults = await callGoogleVisionAPI(imageForApi, state.apiKey);

          if(aiStatusText) aiStatusText.textContent = 'Processing AI detection results...';

          // Get slider values
          const confidence = parseFloat(minConfidence?.value || 0.7);
          const textSize = parseInt(minTextSize?.value || 12);

          // Process results
          const processedResults = processVisionResults(detectionResults, confidence, textSize);

          state.aiResults = processedResults;
          displayAiResults(processedResults);

          if(aiStatus) aiStatus.style.display = 'none';
          const resultsStep = $('#resultsStep');
          if(resultsStep) resultsStep.style.display = 'block';

          toast(`🧠 AI detected ${processedResults.terms.length} text labels with precise coordinates!`);

        } catch(error) {
          console.error('AI processing error:', error);
          const aiStatus = $('#aiStatus');
          if(aiStatus) aiStatus.style.display = 'none';

          if(error.message.includes('API_KEY') || error.message.includes('invalid')) {
            toast('❌ Invalid API key. Please check your Google Vision API key.');
          } else if(error.message.includes('quota') || error.message.includes('limit')) {
            toast('❌ API quota exceeded. Try again later or upgrade your plan.');
          } else if(error.message.includes('billing')) {
            toast('❌ Billing not enabled. Enable billing in Google Cloud Console.');
          } else {
            toast('❌ AI processing failed: ' + error.message);
          }
        }
      };
    }

    // ====== GOOGLE VISION API INTEGRATION ======
    async function callGoogleVisionAPI(imageBase64, apiKey) {
      const API_URL = `https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`;

      // Clean base64 data
      const cleanBase64 = imageBase64.replace(/^data:image\/[a-z]+;base64,/, '');

      const requestBody = {
        requests: [{
          image: {
            content: cleanBase64
          },
          features: [{
            type: 'TEXT_DETECTION',
            maxResults: 100
          }]
        }]
      };

      const response = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`API Error (${response.status}): ${errorData.error?.message || 'Network error'}`);
      }

      const data = await response.json();

      if (data.responses?.[0]?.error) {
        throw new Error(`Vision API Error: ${data.responses[0].error.message}`);
      }

      return data.responses?.[0]?.textAnnotations || [];
    }

    function processVisionResults(textAnnotations, minConfidence, minTextSize) {
      const results = {
        terms: [],
        pins: {},
        metadata: {
          processed_at: new Date().toISOString(),
          total_detections: textAnnotations.length,
          filtered_detections: 0,
          api_used: 'Google Vision API',
          confidence_threshold: minConfidence,
          min_text_size: minTextSize,
          image_dimensions: {
            width: state.imageNatural.w,
            height: state.imageNatural.h
          }
        }
      };

      // Skip the first annotation (it's usually the full document text)
      const individualTexts = textAnnotations.slice(1);

      for(const annotation of individualTexts) {
        const text = annotation.description?.trim();
        if(!text || text.length < 2) continue;

        // Get bounding box
        const vertices = annotation.boundingPoly?.vertices;
        if(!vertices || vertices.length < 4) continue;

        // Calculate bounds and center
        const bounds = calculateTextBounds(vertices);
        if(bounds.width < minTextSize || bounds.height < minTextSize) continue;

        // Convert to normalized coordinates (0-1)
        const normalizedX = bounds.centerX / state.imageNatural.w;
        const normalizedY = bounds.centerY / state.imageNatural.h;

        // Clean up text for geographic labels
        const cleanText = cleanTextLabel(text);
        if(!cleanText) continue;

        // Check for duplicate terms (keep the one with better position)
        if(results.terms.includes(cleanText)) continue;

        results.terms.push(cleanText);
        results.pins[cleanText] = {
          x: Math.max(0.02, Math.min(0.98, normalizedX)),
          y: Math.max(0.02, Math.min(0.98, normalizedY)),
          confidence: 0.8, // Google Vision doesn't always provide confidence for text detection
          originalText: text,
          bounds: bounds
        };

        results.metadata.filtered_detections++;
      }

      return results;
    }

    function calculateTextBounds(vertices) {
      const xs = vertices.map(v => v.x || 0);
      const ys = vertices.map(v => v.y || 0);

      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);

      return {
        minX, maxX, minY, maxY,
        width: maxX - minX,
        height: maxY - minY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2
      };
    }

    function cleanTextLabel(text) {
      // Remove special characters, normalize case
      let clean = text.replace(/[^a-zA-Z0-9\s.-]/g, '').trim();

      // Skip very short or very long texts
      if(clean.length < 2 || clean.length > 50) return null;

      // Skip common non-geographic terms and numbers
      const skipWords = ['THE', 'OF', 'AND', 'OR', 'TO', 'IN', 'FOR', 'WITH', 'ON', 'AT', 'BY', 'FROM', 'UP', 'ABOUT', 'INTO', 'OVER', 'AFTER', 'SCALE', 'KM', 'MILES', 'COPYRIGHT'];
      const upperClean = clean.toUpperCase();
      if(skipWords.some(word => upperClean === word)) return null;

      // Skip if it's just numbers
      if(/^[0-9\s.-]+$/.test(clean)) return null;

      // Capitalize properly for geographic names
      return clean.split(' ').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      ).join(' ');
    }

    // ====== Results Display ======
    function displayAiResults(results) {
      const preview = $('#resultsPreview');
      if(!preview) return;

      let displayText = `🧠 REAL AI Vision Detection Results\n`;
      displayText += `${'='.repeat(50)}\n`;
      displayText += `API Used: ${results.metadata.api_used}\n`;
      displayText += `Processed: ${new Date(results.metadata.processed_at).toLocaleString()}\n`;
      displayText += `Total Detections: ${results.metadata.total_detections}\n`;
      displayText += `Filtered Results: ${results.metadata.filtered_detections}\n`;
      displayText += `Confidence Threshold: ${(results.metadata.confidence_threshold * 100).toFixed(0)}%\n`;
      displayText += `Min Text Size: ${results.metadata.min_text_size}px\n\n`;

      displayText += `📍 Detected Geographic Labels:\n`;
      displayText += `${'='.repeat(40)}\n`;

      results.terms.forEach((term, index) => {
        const pin = results.pins[term];
        displayText += `${String(index + 1).padStart(2)}. "${term}"\n`;
        displayText += `    📍 Position: (${(pin.x * 100).toFixed(1)}%, ${(pin.y * 100).toFixed(1)}%)\n`;
        displayText += `    📏 Bounds: ${pin.bounds.width}×${pin.bounds.height}px\n`;
        if(pin.originalText !== term) {
          displayText += `    📝 Original: "${pin.originalText}"\n`;
        }
        displayText += `\n`;
      });

      if(results.terms.length === 0) {
        displayText += `\n⚠️ No geographic labels detected.\n`;
        displayText += `Try adjusting detection settings or use a clearer map image.\n`;
      }

      preview.textContent = displayText;
    }

    // Import and download AI results
    const importAiResults = $('#importAiResults');
    if(importAiResults) {
      importAiResults.onclick = () => {
        if(!state.aiResults) return;

        let imported = 0;
        state.aiResults.terms.forEach(term => {
          if(!state.terms.includes(term)) {
            state.terms.push(term);
            imported++;
          }
          // Always update pin position (even for existing terms)
          state.pins[term] = {
            x: state.aiResults.pins[term].x,
            y: state.aiResults.pins[term].y
          };
        });

        renderTerms();
        draw();
        persist();

        const aiModal = $('#aiModal');
        if(aiModal) safeRemoveClass(aiModal, 'show');

        toast(`🎉 AI Vision complete! Imported ${imported} new labels and ${Object.keys(state.aiResults.pins).length} precise coordinates`);
      };
    }

    const downloadAiResults = $('#downloadAiResults');
    if(downloadAiResults) {
      downloadAiResults.onclick = () => {
        if(!state.aiResults) return;

        const data = {
          ...state.aiResults,
          version: '2.0',
          source: 'Google Vision API - Real AI Text Detection',
          tol: state.tol
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'real-ai-vision-map-quiz.json';
        a.click();
        URL.revokeObjectURL(url);

        toast('🧠 Real AI results downloaded as JSON');
      };
    }

    // ====== Terms ======
    function renderTerms(){
      const list = $('#termList');
      if(!list) return;

      list.innerHTML = '';
      state.terms.forEach(t =>{
        const row = document.createElement('div');
        row.className = 'term';
        const hasPins = state.pins[t] ? '📍' : '';
        row.innerHTML = `<span title="${t}">${t} ${hasPins}</span>
          <span class="mini">
            <button class="btn secondary" data-sel="${t}" title="Select this term">Select</button>
            <button class="btn ghost" data-del="${t}" title="Delete this term">Del</button>
          </span>`;
        list.appendChild(row);
      });

      const total = $('#total');
      if(total) total.textContent = state.terms.length;

      const progress = Math.min(state.quizIndex + 1, state.terms.length);
      const fcProgress = $('#fcProgress');
      if(fcProgress) fcProgress.textContent = `${progress} / ${state.terms.length}`;
    }

    function addTerm(t){
      t = t.trim();
      if(!t) {
        toast('Please enter a term');
        return false;
      }
      if(t.length > 50) {
        toast('Term too long (max 50 characters)');
        return false;
      }
      if(state.terms.includes(t)) {
        toast('Term already exists');
        return false;
      }
      state.terms.push(t); 
      renderTerms(); 
      persist();
      return true;
    }

    const addTermBtn = $('#addTerm');
    if(addTermBtn) {
      addTermBtn.onclick = ()=>{ 
        const termInput = $('#termInput');
        if(termInput && addTerm(termInput.value)) {
          termInput.value=''; 
        }
      };
    }

    const termInput = $('#termInput');
    if(termInput) {
      termInput.addEventListener('keyup', e=>{ 
        if(e.key==='Enter'){ 
          const addTermBtn = $('#addTerm');
          if(addTermBtn) addTermBtn.click(); 
        }
      });
    }

    const termList = $('#termList');
    if(termList) {
      termList.addEventListener('click', e=>{
        const del = e.target.getAttribute('data-del');
        const sel = e.target.getAttribute('data-sel');
        if(del){
          if(confirm(`Delete term "${del}"?`)) {
            state.terms = state.terms.filter(x=>x!==del);
            delete state.pins[del];
            if(state.selectedTerm === del) state.selectedTerm = null;
            renderTerms(); 
            draw(); 
            persist();
            toast('Term deleted');
          }
        }
        if(sel){ 
          state.selectedTerm = sel; 
          toast('Selected: '+sel);
          // Highlight selected term visually
          $$('[data-sel]').forEach(btn => safeRemoveClass(btn, 'good'));
          safeAddClass(e.target, 'good');
        } 
      });
    }

    const clearTerms = $('#clearTerms');
    if(clearTerms) {
      clearTerms.onclick = ()=>{ 
        if(confirm('Clear all terms and pins?')) {
          state.terms=[]; 
          state.pins={}; 
          state.selectedTerm = null;
          renderTerms(); 
          draw(); 
          persist();
          toast('All terms cleared');
        }
      };
    }

    // Packs
    const PACKS = {
      countries:[
        'Bahrain','Cyprus','Djibouti','Egypt','Eritrea','Ethiopia','Iran','Iraq','Israel','Jordan','Kuwait','Oman','Qatar','Saudi Arabia','Somalia','Sudan','South Sudan','Syria','Turkey','United Arab Emirates','Yemen','Lebanon'
      ],
      features:[
        'Arabian Sea','Black Sea','Caspian Sea','Dead Sea','Euphrates River','Gulf of Aden','Gulf of Oman','Lake Nasser','Mediterranean Sea','Nile River','Persian Gulf','Red Sea','Strait of Hormuz','Suez Canal','Tigris River','Fertile Crescent','Mesopotamia','Sinai Peninsula','Sumer'
      ]
    };

    $$('.chip[data-pack]').forEach(ch=>{
      ch.addEventListener('click',()=>{
        const arr = PACKS[ch.dataset.pack];
        let added = 0;
        arr.forEach(term => {
          if(addTerm(term)) added++;
        });
        toast(`Loaded ${added} new terms`);
      });
    });

    // ====== Modes ======
    $$('.mode-toggle .btn').forEach(btn=>{
      btn.addEventListener('click',()=>setMode(btn.dataset.mode));
    });

    function setMode(m){
      // Validate mode change
      if(m === 'quiz' && state.terms.length === 0) {
        toast('Add some terms first');
        return;
      }

      state.mode = m; 

      // Update UI
      $$('.mode-toggle .btn').forEach(b => safeRemoveClass(b, 'good'));
      const modeBtn = $(`[data-mode="${m}"]`);
      if(modeBtn) safeAddClass(modeBtn, 'good');

      const modeLabel = $('#modeLabel');
      if(modeLabel) {
        modeLabel.textContent = m==='author' ? 'Author mode' : m==='quiz' ? 'Quiz mode' : 'Flashcards';
      }

      const flash = $('#flash');
      if(flash) safeToggleClass(flash, 'show', m==='flash');

      // Reset selections
      state.selectedTerm = null;
      $$('[data-sel]').forEach(btn => safeRemoveClass(btn, 'good'));

      draw();
      updateButtons();
    }

    function updateButtons() {
      const hasTerms = state.terms.length > 0;
      const hasImage = !!state.image;
      const hasPins = Object.keys(state.pins).length > 0;

      const startQuiz = $('#startQuiz');
      if(startQuiz) startQuiz.disabled = !hasTerms;

      const revealBtn = $('#revealBtn');
      if(revealBtn) revealBtn.disabled = state.mode !== 'quiz' || !currentTarget();

      const showPins = $('#showPins');
      if(showPins) showPins.disabled = !hasPins;

      const undoBtn = $('#undoBtn');
      if(undoBtn) undoBtn.disabled = state.history.length === 0;
    }

    // ====== Canvas interaction ======
    let draggingKey = null;
    let dragStartPos = null;

    if(canvas) {
      canvas.addEventListener('mousedown', onPointerDown);
      canvas.addEventListener('touchstart', onPointerDown, {passive:false});
    }

    function getPos(evt){
      if(!canvas) return {x:0, y:0, w:1, h:1};

      const rect = canvas.getBoundingClientRect();
      const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
      const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      return {x, y, w: rect.width, h: rect.height};
    }

    function onPointerDown(evt){
      evt.preventDefault();

      if(state.isLoading) return;

      const {x,y,w,h} = getPos(evt);
      dragStartPos = {x, y};

      if(state.mode==='author'){
        if(!state.image) {
          toast('Upload an image first');
          return;
        }
        if(!state.selectedTerm){ 
          toast('Select a term first'); 
          return; 
        }

        // Check if dragging existing pin
        const key = hitTest(x,y);
        if(key && key === state.selectedTerm){ 
          draggingKey = key; 
          return; 
        }

        // Place new pin
        placePin(state.selectedTerm, x/w, y/h); 
        state.history.push({type:'place', term: state.selectedTerm});
        if(state.history.length > 50) state.history.shift(); // Limit history
        draw();
        updateButtons();

      } else if(state.mode==='quiz'){
        if(!currentTarget()) { 
          toast('Start quiz first'); 
          return; 
        }

        const term = currentTarget();
        const pin = state.pins[term];
        if(!pin){ 
          toast('No pin for this term yet'); 
          return; 
        }

        const dx = x - pin.x * w; 
        const dy = y - pin.y * h; 
        const dist = Math.hypot(dx,dy);

        if(dist <= state.tol){
          state.score++; 
          state.streak++; 
          toast('Correct! ✅');
          confetti(x,y);
          setTimeout(nextTarget, 500);
        } else {
          state.streak = 0;
          flashShake();
          toast('Not quite. Try again or Reveal.');
        }
        updateScore();
        draw();

      } else if(state.mode==='flash'){
        flipFlash();
      }
    }

    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('touchmove', onPointerMove, {passive:false});
    window.addEventListener('mouseup', onPointerEnd);
    window.addEventListener('touchend', onPointerEnd);

    function onPointerMove(evt){
      if(!draggingKey || !dragStartPos) return;
      evt.preventDefault();

      const {x,y,w,h} = getPos(evt);
      placePin(draggingKey, x/w, y/h);
      draw();
    }

    function onPointerEnd(evt) {
      draggingKey = null;
      dragStartPos = null;
    }

    function hitTest(px,py){
      if(!canvas) return null;

      const tolerance = 20;
      for(const [term,p] of Object.entries(state.pins)){
        const rect = canvas.getBoundingClientRect();
        const x = p.x * rect.width; 
        const y = p.y * rect.height;
        if(Math.hypot(px-x, py-y) < tolerance) return term;
      }
      return null;
    }

    function placePin(term, nx, ny){
      // Ensure pin is within bounds
      state.pins[term] = {
        x: clamp(nx, 0.02, 0.98), 
        y: clamp(ny, 0.02, 0.98)
      }; 
      persist();
    }

    function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

    // ====== Drawing ======
    function draw(){
      if(!canvas || !ctx) return;

      try {
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;

        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = '#0a0f22';
        ctx.fillRect(0,0,w,h);

        if(state.image && state.imageNatural.w > 0){
          // Fit image to canvas with contain
          const rCan = w/h, rImg = state.imageNatural.w/state.imageNatural.h;
          let dw,dh,dx,dy;
          if(rImg>rCan){ 
            dw = w; dh = w/rImg; dx = 0; dy = (h-dh)/2; 
          } else { 
            dh = h; dw = h*rImg; dy = 0; dx = (w-dw)/2; 
          }
          ctx.drawImage(imgEl, dx,dy,dw,dh);
        } else {
          ctx.fillStyle = '#0d1533';
          ctx.fillRect(0,0,w,h);
          ctx.fillStyle = 'rgba(255,255,255,.08)';
          ctx.textAlign='center'; 
          ctx.font='600 16px system-ui';
          const message = state.isLoading ? 'Loading image...' : 'Upload a map image and use REAL AI Vision';
          ctx.fillText(message, w/2, h/2);
        }

        // Draw pins
        if((state.showPins || state.mode==='author') && Object.keys(state.pins).length > 0){
          for(const [term,p] of Object.entries(state.pins)){
            drawPin(p.x*w, p.y*h, term, term === state.selectedTerm);
          }
        }

        updateStatus(); 
        updateScore(); 
        updateTargetLabel();
      } catch(e) {
        console.error('Draw error:', e);
      }
    }

    function drawPin(x,y, label, isSelected = false){
      if(!ctx || isNaN(x) || isNaN(y)) return;

      ctx.save();

      // Pin circle
      ctx.fillStyle = isSelected ? '#fbbf24' : 'rgba(122,162,255,1)';
      ctx.strokeStyle = '#fff'; 
      ctx.lineWidth = 2;
      ctx.beginPath(); 
      ctx.arc(x,y,7,0,Math.PI*2); 
      ctx.fill(); 
      ctx.stroke();

      // Label background and text
      ctx.font='600 12px system-ui'; 
      ctx.textBaseline='bottom';
      const pad = 6; 
      const textWidth = Math.min(ctx.measureText(label).width + pad*2, 150);
      const canvasRect = canvas ? canvas.getBoundingClientRect() : {width: 800};
      const bx = clamp(x - textWidth/2, 4, canvasRect.width - textWidth - 4);
      const by = y - 16;

      ctx.fillStyle = 'rgba(12,18,44,.85)';
      roundRect(ctx, bx, by-20, textWidth, 18, 8); 
      ctx.fill();

      ctx.fillStyle = '#e7ecff'; 
      ctx.textAlign='center';
      // Truncate long labels
      const truncated = label.length > 20 ? label.substring(0, 17) + '...' : label;
      ctx.fillText(truncated, bx+textWidth/2, by-5);

      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){
      if(w < 2*r) r = w/2;
      if(h < 2*r) r = h/2;
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function updateStatus(){
      const status = $('#status');
      if(!status) return;

      if(state.isLoading) {
        status.textContent = 'Loading...';
        status.className = 'pill loading';
      } else if(state.image) {
        status.textContent = 'Image ready';
        status.className = 'pill';
      } else {
        status.textContent = 'No image';
        status.className = 'pill';
      }
    }

    function updateScore(){
      const score = $('#score');
      if(score) score.textContent = state.score;

      const total = $('#total');
      if(total) total.textContent = state.terms.length;

      const streak = $('#streak');
      if(streak) streak.textContent = state.streak;
    }

    function updateTargetLabel(){
      const targetName = $('#targetName');
      if(targetName) targetName.textContent = currentTarget() || '—';
    }

    // ====== Toast system ======
    function toast(msg){
      state.toastQueue.push(msg);
      showNextToast();
    }

    function showNextToast() {
      if(state.toastQueue.length === 0) return;

      const el = $('#toast'); 
      if(!el || safeHasClass(el, 'show')) return; // Wait for current toast

      const msg = state.toastQueue.shift();
      el.textContent = msg; 
      safeRemoveClass(el, 'show'); 
      void el.offsetWidth; 
      safeAddClass(el, 'show');

      setTimeout(() => {
        safeRemoveClass(el, 'show');
        setTimeout(showNextToast, 200); // Show next toast after delay
      }, 1600);
    }

    function flashShake(){
      const st = $('#stage'); 
      if(!st) return;

      safeRemoveClass(st, 'shake'); 
      void st.offsetWidth; 
      safeAddClass(st, 'shake');
    }

    // ====== Quiz logic ======
    function shuffle(arr){
      const newArr = [...arr];
      for(let i=newArr.length-1;i>0;i--){ 
        const j=Math.floor(Math.random()*(i+1)); 
        [newArr[i],newArr[j]]=[newArr[j],newArr[i]]; 
      }
      return newArr;
    }

    function startQuiz(){
      if(state.terms.length === 0) {
        toast('Add some terms first');
        return;
      }

      const termsWithPins = state.terms.filter(term => state.pins[term]);
      if(termsWithPins.length === 0) {
        toast('Place some pins first in Author mode or use Real AI Vision');
        return;
      }

      state.quizOrder = shuffle(termsWithPins);
      state.quizIndex = 0; 
      state.score=0; 
      state.streak=0; 
      setMode('quiz');
      updateTargetLabel(); 
      updateScore();
      draw();
      toast(`Quiz started with ${termsWithPins.length} terms`);
    }

    function currentTarget(){ 
      return state.quizOrder[state.quizIndex]; 
    }

    function nextTarget(){
      if(state.quizIndex < state.quizOrder.length-1){ 
        state.quizIndex++; 
      } else { 
        const percentage = Math.round((state.score / state.quizOrder.length) * 100);
        toast(`Quiz complete! Score: ${state.score}/${state.quizOrder.length} (${percentage}%)`); 
      }
      updateTargetLabel();
      updateScore();
    }

    const startQuizBtn = $('#startQuiz');
    if(startQuizBtn) startQuizBtn.onclick = startQuiz;

    const nextBtn = $('#nextBtn');
    if(nextBtn) nextBtn.onclick = nextTarget;

    const revealBtn = $('#revealBtn');
    if(revealBtn) {
      revealBtn.onclick = ()=>{
        const term = currentTarget(); 
        if(!term) {
          toast('No active target');
          return;
        }
        const p = state.pins[term]; 
        if(!p) { 
          toast('No pin for this term'); 
          return; 
        }
        const rect = canvas ? canvas.getBoundingClientRect() : {width: 800, height: 600};
        revealPing(p.x * rect.width, p.y * rect.height);
        toast(`Answer: ${term}`);
      };
    }

    // Pins toggle
    const showPins = $('#showPins');
    if(showPins) {
      showPins.onclick = ()=>{ 
        state.showPins = !state.showPins; 
        draw(); 
        toast(state.showPins ? 'Pins shown' : 'Pins hidden');
      };
    }

    // Tolerance
    const tolInput = $('#tol');
    if(tolInput) {
      tolInput.addEventListener('input', e=>{ 
        state.tol = +e.target.value; 
        const tolVal = $('#tolVal');
        if(tolVal) tolVal.textContent = state.tol; 
        persist();
      });
    }

    // Undo
    const undoBtn = $('#undoBtn');
    if(undoBtn) {
      undoBtn.onclick = ()=>{
        const last = state.history.pop();
        if(!last) {
          toast('Nothing to undo');
          return;
        }
        if(last.type==='place'){
          delete state.pins[last.term]; 
          draw();
          persist();
          toast('Undone pin placement');
        }
        updateButtons();
      };
    }

    // ====== Flashcards ======
    function setupFlash(){
      if(state.terms.length === 0) return;
      state.quizOrder = shuffle(state.terms.slice());
      state.quizIndex = 0; 
      updateFlash();
    }

    function updateFlash(){
      const fcTerm = $('#fcTerm');
      if(fcTerm) fcTerm.textContent = currentTarget() || '—';

      const pct = state.terms.length ? ((state.quizIndex)/state.terms.length)*100 : 0;
      const fcBar = $('#fcBar');
      if(fcBar) fcBar.style.width = pct+'%';

      const progress = Math.min(state.quizIndex + 1, state.terms.length);
      const fcProgress = $('#fcProgress');
      if(fcProgress) fcProgress.textContent = `${progress} / ${state.terms.length}`;
    }

    function flipFlash(){
      const term = currentTarget(); 
      if(!term) {
        toast('No terms available');
        return;
      }
      const p = state.pins[term]; 
      if(p && canvas){ 
        const rect = canvas.getBoundingClientRect();
        revealPing(p.x * rect.width, p.y * rect.height); 
        toast(`Answer: ${term}`);
      } else {
        toast(`No pin set for: ${term}`);
      }
    }

    const fcNext = $('#fcNext');
    if(fcNext) {
      fcNext.onclick = ()=>{ 
        if(state.quizIndex < state.quizOrder.length - 1){ 
          state.quizIndex++; 
          updateFlash(); 
        } else {
          toast('End of flashcards');
        }
      };
    }

    const fcKnow = $('#fcKnow');
    const fcUnsure = $('#fcUnsure');
    if(fcKnow && fcNext) fcKnow.onclick = fcNext.onclick;
    if(fcUnsure && fcNext) fcUnsure.onclick = fcNext.onclick;

    // ====== Keyboard shortcuts ======
    window.addEventListener('keydown', e=>{
      // Prevent conflicts with text inputs
      if(e.target.tagName === 'INPUT') return;

      if(e.code==='Space'){ 
        e.preventDefault(); 
        if(state.mode==='flash'){ 
          flipFlash(); 
        }
      }
      if(e.key==='n' || e.key==='N'){ 
        e.preventDefault();
        nextTarget(); 
      }
      if(e.key==='r' || e.key==='R'){ 
        e.preventDefault();
        const revealBtn = $('#revealBtn');
        if(revealBtn) revealBtn.click();
      }
      if(e.key==='Escape'){
        e.preventDefault();
        // Close modal or reset selections
        const aiModal = $('#aiModal');
        if(aiModal && safeHasClass(aiModal, 'show')) {
          safeRemoveClass(aiModal, 'show');
        } else {
          state.selectedTerm = null;
          $$('[data-sel]').forEach(btn => safeRemoveClass(btn, 'good'));
          draw();
        }
      }
    });

    // ====== Effects ======
    function revealPing(x,y){
      if(!ctx || isNaN(x) || isNaN(y)) return;

      const originalDraw = draw;
      draw(); // Draw current state

      // Add ping effect
      ctx.save();
      ctx.strokeStyle = 'rgba(122,162,255,.9)'; 
      ctx.lineWidth = 3;
      ctx.beginPath(); 
      ctx.arc(x,y,20,0,Math.PI*2); 
      ctx.stroke(); 
      ctx.restore();

      // Restore normal drawing after effect
      setTimeout(originalDraw, 800);
    }

    function confetti(x,y){
      if(isNaN(x) || isNaN(y)) return;

      const stage = $('#stage');
      if(!stage) return;

      const N = 20;
      const container = document.createElement('div'); 
      container.style.cssText = 'position:absolute; left:0; top:0; pointer-events:none; width:100%; height:100%; z-index:999;';
      stage.appendChild(container);

      for(let i=0;i<N;i++){
        const p = document.createElement('div');
        p.style.cssText = `
          position:absolute; left:${x}px; top:${y}px; width:6px; height:10px; border-radius:2px;
          background:hsl(${Math.random()*360},80%,60%); transform:translate(-50%,-50%);
          transition:transform .8s ease, opacity .9s ease; z-index:1000;
        `;
        container.appendChild(p);

        const ang = Math.random()*Math.PI*2; 
        const dist = 50 + Math.random()*50;
        requestAnimationFrame(()=>{
          p.style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist + 30}px) rotate(${Math.random()*360}deg)`;
          p.style.opacity = 0;
        });
      }
      setTimeout(()=>container.remove(), 900);
    }

    // ====== Export / Import / Reset ======
    const exportBtn = $('#exportBtn');
    if(exportBtn) {
      exportBtn.onclick = ()=>{
        try {
          const data = {
            terms: state.terms,
            pins: state.pins,
            tol: state.tol,
            version: '2.0',
            exportDate: new Date().toISOString(),
            source: 'Map Quiz Studio with Real AI Vision'
          };
          const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); 
          a.href=url; 
          a.download='map-quiz-deck.json'; 
          a.click(); 
          URL.revokeObjectURL(url);
          toast('Deck exported successfully');
        } catch(e) {
          toast('Export failed');
          console.error('Export error:', e);
        }
      };
    }

    const importInput = $('#importInput');
    if(importInput) {
      importInput.addEventListener('change', e=>{
        const file = e.target.files[0]; 
        if(!file) return;

        if(!file.type.includes('json')) {
          toast('Please select a JSON file');
          return;
        }

        const fr = new FileReader(); 
        fr.onload = ()=>{
          try{ 
            const data = JSON.parse(fr.result);

            // Validate imported data
            if(!Array.isArray(data.terms)) {
              toast('Invalid deck format');
              return;
            }

            state.terms = data.terms.slice(0, 100) || []; // Limit terms
            state.pins = data.pins || {}; 
            state.tol = clamp(data.tol || 24, 10, 60);

            const tolInput = $('#tol');
            if(tolInput) tolInput.value = state.tol;

            const tolVal = $('#tolVal');
            if(tolVal) tolVal.textContent = state.tol;

            renderTerms(); 
            draw(); 
            persist();
            toast(`Imported ${state.terms.length} terms`);
          } catch(err){ 
            toast('Invalid JSON file'); 
            console.error('Import error:', err);
          }
        }; 
        fr.onerror = () => toast('Failed to read file');
        fr.readAsText(file);
      });
    }

    const resetBtn = $('#resetBtn');
    if(resetBtn) {
      resetBtn.onclick = ()=>{
        if(confirm('Clear all terms, pins, and image? This cannot be undone.')){
          state.terms=[]; 
          state.pins={}; 
          state.image=null; 
          imgEl.src=''; 
          state.score=0; 
          state.streak=0; 
          state.history=[];
          state.selectedTerm=null;
          state.imageNatural = {w:0,h:0};

          const imageError = $('#imageError');
          if(imageError) imageError.style.display = 'none';

          renderTerms(); 
          draw(); 
          updateButtons();
          updateAiButtons();
          persist();
          toast('Everything cleared');
        }
      };
    }

    // ====== Persistence ======
    function persist(){
      try {
        localStorage.setItem('mqz_terms', JSON.stringify(state.terms));
        localStorage.setItem('mqz_pins', JSON.stringify(state.pins));
        localStorage.setItem('mqz_tol', String(state.tol));
        localStorage.setItem('mqz_image', state.image || '');
      } catch(e) {
        console.warn('Failed to save to localStorage:', e);
        // Fallback: continue without persistence
      }
    }

    function loadPersist(){
      try{
        const terms = JSON.parse(localStorage.getItem('mqz_terms')||'[]');
        const pins = JSON.parse(localStorage.getItem('mqz_pins')||'{}');
        const tol = +localStorage.getItem('mqz_tol')||24;
        const image = localStorage.getItem('mqz_image') || null;

        // Validate loaded data
        if(Array.isArray(terms)) state.terms = terms.slice(0, 100);
        if(typeof pins === 'object' && pins !== null) state.pins = pins;
        state.tol = clamp(tol, 10, 60);

        if(image && image.startsWith('data:image/')) {
          state.image = image;
          imgEl.src = image;
        }

        const tolInput = $('#tol');
        if(tolInput) tolInput.value = state.tol;

        const tolVal = $('#tolVal');
        if(tolVal) tolVal.textContent = state.tol;
      } catch(e) { 
        console.warn('Failed to load from localStorage:', e);
        // Continue with default state
      }
    }

    // ====== Error handling ======
    window.addEventListener('error', (e) => {
      console.error('Global error:', e.error);
      toast('An error occurred. Please refresh the page.');
    });

    window.addEventListener('unhandledrejection', (e) => {
      console.error('Unhandled promise rejection:', e.reason);
      e.preventDefault();
    });

    // ====== Init ======
    function init(){
      try {
        loadPersist(); 
        renderTerms(); 
        resizeCanvas(); 
        setMode('author'); 
        setupFlash();
        updateScore(); 
        updateTargetLabel();
        updateButtons();
        updateAiButtons();
        updateApiStatus();

        // Initial draw
        setTimeout(() => {
          draw();
          toast('🧠 Map Quiz Studio loaded with REAL AI Vision!');
        }, 100);
      } catch(e) {
        console.error('Initialization error:', e);
        toast('Failed to initialize. Please refresh the page.');
      }
    }

    // Start the application
    if(document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
